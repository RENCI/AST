
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>harvester.fetch_station_data &#8212; AST  documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for harvester.fetch_station_data</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="c1"># SPDX-FileCopyrightText: 2022 Renaissance Computing Institute. All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: GPL-3.0-or-later</span>
<span class="c1"># SPDX-License-Identifier: LicenseRef-RENCI</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>

<span class="c1">#</span>
<span class="c1"># For each new source: Create a subclass that defines the functions:</span>
<span class="c1"># fetch_single_data(station)-&gt; pd.DataFrame</span>
<span class="c1"># fetch_single_metadata(station,periods)-&gt; pd.DataFrame</span>
<span class="c1">#</span>
<span class="c1"># OUTPUT product data are generated by </span>
<span class="c1">#    1) Grab the rawe data from the selected data source</span>
<span class="c1">#    2) Build interpolation the data </span>
<span class="c1">#    3) resample the interpolated data at the desired resample_rate</span>
<span class="c1">#        it is possible for these data to still contain NaNs</span>
<span class="c1"># excluded stations with insufficient data.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">utilities.utilities</span> <span class="k">import</span> <span class="n">utilities</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1">#Contrails</span>
<span class="kn">import</span> <span class="nn">urllib</span>
<span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="k">import</span> <span class="ne">ConnectionError</span>
<span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="k">import</span> <span class="n">Timeout</span>
<span class="kn">from</span> <span class="nn">requests.exceptions</span> <span class="k">import</span> <span class="n">HTTPError</span>
<span class="kn">import</span> <span class="nn">xmltodict</span>

<span class="c1"># NOAA/NOS</span>
<span class="kn">import</span> <span class="nn">noaa_coops</span> <span class="k">as</span> <span class="nn">coops</span>

<span class="c1"># NDBC # Continue to need siphon to get Lat/Lon values</span>
<span class="kn">from</span> <span class="nn">siphon.simplewebservice.ndbc</span> <span class="k">import</span> <span class="n">NDBC</span>
<span class="kn">import</span> <span class="nn">buoypy</span> <span class="k">as</span> <span class="nn">bp</span>

<span class="c1"># THREDDS (ADCIRC model)</span>
<span class="kn">import</span> <span class="nn">netCDF4</span> <span class="k">as</span> <span class="nn">nc4</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">siphon.catalog</span> <span class="k">import</span> <span class="n">TDSCatalog</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="n">GLOBAL_TIMEZONE</span><span class="o">=</span><span class="s1">&#39;gmt&#39;</span> <span class="c1"># Every source is set or presumed to return times in this zone</span>

<span class="n">GLOBAL_FILL_VALUE</span><span class="o">=</span><span class="s1">&#39;-99999&#39;</span>  <span class="c1"># Always replaces final np.nans with this.</span>

<span class="c1">#UNITS=&#39;meters&#39; # Now the code only applies to WL</span>
<div class="viewcode-block" id="map_product_to_harvester_units"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.map_product_to_harvester_units">[docs]</a><span class="k">def</span> <span class="nf">map_product_to_harvester_units</span><span class="p">(</span><span class="n">product</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The harvester dataset should be returning consistent metric units </span>
<span class="sd">    for all sources. This dictionary performs the translation for supported </span>
<span class="sd">    data products to known units This is mosty used for metadata construction</span>

<span class="sd">    Parameters:</span>
<span class="sd">        product: (str) The generic data product name (water_level, wind_speed, etc)</span>

<span class="sd">    Returns:</span>
<span class="sd">        units: (str) The chosen data unit for the specified product</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">product_unit_maps</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;water_level&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;predictions&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;hourly_height&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;wave_height&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;river_water_level&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;coastal_water_level&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span>
        <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span><span class="s1">&#39;mb&#39;</span><span class="p">,</span>
        <span class="s1">&#39;wind_speed&#39;</span><span class="p">:</span><span class="s1">&#39;mps&#39;</span>
        <span class="p">}</span>
    <span class="k">if</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">product_unit_maps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">product_unit_maps</span><span class="p">[</span><span class="n">product</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;NA&#39;</span>
    <span class="k">return</span> <span class="n">unit</span></div>

<div class="viewcode-block" id="replace_and_fill"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.replace_and_fill">[docs]</a><span class="k">def</span> <span class="nf">replace_and_fill</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace all Nans with &#39;None&quot; values with GLOBAL_FILL_VALUE</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">GLOBAL_FILL_VALUE</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="stations_resample"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.stations_resample">[docs]</a><span class="k">def</span> <span class="nf">stations_resample</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">sample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample (all stations) on a pecified (eg 15min) basis. Setting sample_min</span>
<span class="sd">        to zero retains full resolution. Defaults to 15min</span>

<span class="sd">    NOTE: Final aggregated data still have flanked nans for some stations because</span>
<span class="sd">    The reported times might have been differently staggered. Often the case with river and</span>
<span class="sd">    buoy data </span>

<span class="sd">    Parameters:</span>
<span class="sd">        df: A time series x stations dataframe</span>
<span class="sd">        sample_min. (Dafaut=15mins) A numerical value for the number of mins to resample</span>
<span class="sd">            setting to 0 disables any resampling and returns the raw data at full precision</span>

<span class="sd">    Returns:</span>
<span class="sd">        df_out. New time series every sample_mins x stations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sample_mins</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;resample freq set to 0. return all&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="n">timesample</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{sample_mins}</span><span class="s1">min&#39;</span>
    <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resampling freq set to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">timesample</span><span class="p">))</span>
    <span class="n">dx</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Grouper</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">timesample</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">dx</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;TIME&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="stations_interpolate"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.stations_interpolate">[docs]</a><span class="k">def</span> <span class="nf">stations_interpolate</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate each station column in the dataframe. </span>
<span class="sd">    Final aggregated data still have flanked nans for some stations. </span>
<span class="sd">    Defaults to: method=&#39;polynomial&#39;, order=1, limit=1</span>

<span class="sd">    Parameters:</span>
<span class="sd">        df: A time series x stations data frame</span>

<span class="sd">    Returns:</span>
<span class="sd">        df_out. New time series x stations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Interpolating station data&#39;</span> <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;polynomial&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="fetch_station_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.fetch_station_data">[docs]</a><span class="k">class</span> <span class="nc">fetch_station_data</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We expect upon entry to this class a list of station ids. The content of this list can</span>
<span class="sd">    vary depending on chosen data source. But usually this is simply a list of (str) station ids. If</span>
<span class="sd">    an ADCIRC Fort63_style lookup is requested, Then the elements of this list are tuples (stations,node)</span>

<span class="sd">    A list of times (periods) is required. The list contents can vary with data source. Generally, this is</span>
<span class="sd">    a list of one element; a tuple such as [(time1,time2)]. However, the caller could gang together multiple tuple ranges.</span>
<span class="sd">    For calling ADCIRC data, periods is a list of ASGS URLs (which imply a range of times)</span>

<span class="sd">    The output data are aggregated station products into a dataframe: (TIME vs PRODUCT)</span>
<span class="sd">    with TIME as datetime timestamps and a column of data of the desired units and with a column</span>
<span class="sd">    name of the station</span>

<span class="sd">   Default return products wil be on the sampling_mins frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        stations:  A list of stations &lt;str&gt; or &lt;tuples&gt; of (station,adcirc node) (str,int) </span>
<span class="sd">        periods: A list of tuples. [(time1,time2)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="o">=</span><span class="n">stations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_periods</span><span class="o">=</span><span class="n">periods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resampling_mins</span><span class="o">=</span><span class="n">resample_mins</span>

<div class="viewcode-block" id="fetch_station_data.aggregate_station_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.fetch_station_data.aggregate_station_data">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_station_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over the list of stations and fetch the products using the method of the relevant subclasses. Then concatenate them info single dataframe</span>
<span class="sd">        nans now get converted to the value in GLOBAL_FILL_VALUE</span>

<span class="sd">        Returns:</span>
<span class="sd">            Aggregated results: A dataframe (times x stations) for all periods and input stations</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aggregateData</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">excludedStations</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;An exception of type </span><span class="si">{0}</span><span class="s2"> occurred. Arguments:</span><span class="se">\n</span><span class="si">{1!r}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>    
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_single_product</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_periods</span><span class="p">)</span>
                <span class="n">dx_int</span> <span class="o">=</span> <span class="n">stations_interpolate</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
                <span class="n">aggregateData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stations_resample</span><span class="p">(</span><span class="n">dx_int</span><span class="p">,</span> <span class="n">sample_mins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_resampling_mins</span><span class="p">))</span>
                <span class="c1">#tm.sleep(2) # sleep 2 secs</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">excludedStations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Error Value: Probably the station simply had no data; Skip </span><span class="si">{station}</span><span class="s1">, msg </span><span class="si">{message}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggregateData</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No site data was found for the given site_id list. Perhaps the server is down or file doesnt exist&#39;</span><span class="p">)</span>
            <span class="c1">##return np.nan</span>
            <span class="c1">#sys.exit(1) # Keep processing the remaining list</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Stations were excluded&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">excludedStations</span><span class="p">)))</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Stations included&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aggregateData</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">aggregateData</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">df_data</span><span class="o">.</span><span class="n">index</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Check for time duplicates&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Duplicated data times found . will keep first value(s) only&quot;</span><span class="p">)</span>
                <span class="n">df_data</span> <span class="o">=</span> <span class="n">df_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">df_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_data</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;had duplicate times {len(idx)} {len(df_data.index)}&#39;</span><span class="p">)</span>
            <span class="c1">#df_data.dropna(how=&#39;all&#39;, axis=1, inplace=True)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">replace_and_fill</span><span class="p">(</span><span class="n">df_data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Aggregate: error: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="c1">##df_data=np.nan</span>
        <span class="n">df_data</span> <span class="o">=</span> <span class="n">df_data</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">df_data</span></div>

<div class="viewcode-block" id="fetch_station_data.aggregate_station_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.fetch_station_data.aggregate_station_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_station_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over the list of stations and aggregate the metadata using the method of the relevant subclasses. Then concatenate info single dataframe</span>
<span class="sd">        Transpose final data to have stations as index</span>
<span class="sd">        nans now get converted to the value in GLOBAL_FILL_VALUE</span>

<span class="sd">        Returns:</span>
<span class="sd">            Aggregated meadata: A dataframe (stations x metacolumns) for all input stations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aggregateMetaData</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">excludedStations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;A metadata exception of type </span><span class="si">{0}</span><span class="s2"> occurred. Arguments:</span><span class="se">\n</span><span class="si">{1!r}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stations</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_single_metadata</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
                <span class="n">aggregateMetaData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
                <span class="c1">#tm.sleep(2) # sleep 2 secs</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Iterate: Kept station is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">station</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">excludedStations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">ex</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Error Value: Metadata: </span><span class="si">{station}</span><span class="s1">, msg </span><span class="si">{message}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aggregateMetaData</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Metadata: No site data was found for the given site_id list. Perhaps the server is down Exit&#39;</span><span class="p">)</span>
            <span class="c1">#sys.exit(1) # Process remaining list</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;{len(excludedStations)} Metadata Stations were excluded&#39;</span><span class="p">)</span>
        <span class="n">df_meta</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">aggregateMetaData</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1">#df_meta.dropna(how=&#39;all&#39;, axis=1, inplace=True)</span>
        <span class="n">df_meta</span> <span class="o">=</span> <span class="n">replace_and_fill</span><span class="p">(</span><span class="n">df_meta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>

<span class="c1">#####################################################################################</span>
<span class="c1">##</span>
<span class="c1">## Fetching the ADCIRC NODE data from TDS or a local filesystem</span>
<span class="c1">##</span>

<span class="c1">## The fort61 file contains INTERPOLATED values of the solution to a specific lon,lat point.  </span>
<span class="c1">## For the fort.63, we are extracting time series from specific node numbers.  </span>
<span class="c1">## Unless the lon,lat point is very close to the specified node, these will be slightly different.</span>

<div class="viewcode-block" id="adcirc_fetch_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.adcirc_fetch_data">[docs]</a><span class="k">class</span> <span class="nc">adcirc_fetch_data</span><span class="p">(</span><span class="n">fetch_station_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fetching WL data from ADCIRC can be done in one of two ways. The default approach is based</span>
<span class="sd">    on the fort.61.nc type solution where lat/lons/WL are extracted from the ADCIRC netCDF4 fort.61.nc file. This</span>
<span class="sd">    approach simply requires a list of stationids for query. This returns WLs that are interpolations of the ADCIRC</span>
<span class="sd">    grid data. </span>

<span class="sd">    An alternative approach is based on using fort.63.nc data. To use the fort.63_style approach requires a more</span>
<span class="sd">    informative input list of stations.A dataframe with (at least) two columns with headers: stationid and nodeid where nodeid is the pre-established</span>
<span class="sd">    grid-specific ADCIRC nodeid corresponding to the station. Required minimum column headers: (stationid, Node)</span>
<span class="sd">    The nodeid indexing is that used by ADCIRC and is relative to starting at the value 1 !</span>

<span class="sd">    Currently available products:</span>
<span class="sd">    water_level (default)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        station_id_list: list of station_ids to pass to ADCIRC</span>
<span class="sd">        periods: &lt;list&gt; of valid ADCIRC urls tuples (*63.nc,*.61.nc) for aggregation </span>
<span class="sd">        fort63_style: &lt;bool&gt; If True use the fort.63-based approach</span>
<span class="sd">                    If True then station_id_list: a CSV file containing columns of, at least, stationid and nodeid. </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">products</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;water_level&#39;</span><span class="p">:</span><span class="s1">&#39;water_level&#39;</span>  <span class="c1"># 6 min</span>
            <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_remove_empty_url_pointers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_periods</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop through the entire list of adcirc urls and remove any entries that report a File Not Found error</span>
<span class="sd">        We expect to be able to remove many urls. The only time a hard failure occurs is if all urls are not found</span>

<span class="sd">        Parameters:</span>
<span class="sd">            in_periods: &lt;list(str)&gt; of proposed ADCIRC file urls</span>
<span class="sd">        Returns:</span>
<span class="sd">            new_periods: &lt;list(str)&gt; of proposed urls that wee actually found at the source</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_periods</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">in_periods</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">nc4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="n">new_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;URL not found: Remove url </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_periods</span>

<span class="c1">## TODO this cast method is is clumsy</span>
<div class="viewcode-block" id="adcirc_fetch_data.type_ADCIRC_cast"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.adcirc_fetch_data.type_ADCIRC_cast">[docs]</a>    <span class="k">def</span> <span class="nf">type_ADCIRC_cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to determine if the input adcirc data (df) was a Forecast or a Nowcast type dataset by simply </span>
<span class="sd">        examining the associated url. Ths method can assign hurricane or synoptic datasets. This method is generally</span>
<span class="sd">        used to build consistent metadata objects for AST  </span>

<span class="sd">        Attempt to find the url starttime value from the url name. Ascertain if this starttime is &lt; or &gt; the actual entry time in the df.</span>
<span class="sd">        Simply compare the last timeseries value to the url starttime. if timeseries &gt; starttime than it is a forecast else a nowcast</span>

<span class="sd">        url TIME are expected to reside in url.split(&#39;/&#39;)[-6]. If that entry cannot be assigned to a datetime (ValueError), </span>
<span class="sd">        it is checked if it could be an advisory (int) and thus a huricane. </span>


<span class="sd">        If the input url is a LOCAL data file, then [-6] probably doesn&#39;t exist we can make no assumptions about length of name or nomenclature</span>
<span class="sd">        Just assume it is a FORECAST if indexing errors occur</span>


<span class="sd">        Assumes the times series are ordered.</span>

<span class="sd">        If the input url is a LOCAL data file, then we can make no assumptions about length of name or nomenclature</span>
<span class="sd">        Just assume it is a FORECAST if indexing errors occur</span>

<span class="sd">        Parameters:</span>
<span class="sd">            url: &lt;str&gt; The ADCIRC netCDG4 url to compare</span>
<span class="sd">            df: &lt;DataFrame&gt;. The ADCIRC WL read from the associated url</span>

<span class="sd">        Returns:</span>
<span class="sd">              Either NOWCAST or FORECAST</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span> <span class="c1"># Account for ctime/calender changes in pandas. Thx !.</span>

        <span class="c1">#  Too short and it must be local</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">starttime</span><span class="o">=</span><span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Found (probably) a LOCAL netCDF file: Assume a FORECAST </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;FORECAST&#39;</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#Synoptic ?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">urltime</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">%H&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timeseries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">urltime</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;FORECAST&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;NOWCAST&#39;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Synoptic time check failed&#39;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;synoptic time check hard failed: Error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Hurricane ?</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">urltime</span> <span class="o">=</span> <span class="n">starttime</span>
            <span class="n">advnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">urltime</span><span class="p">)</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Found Hurricane Advisory value: Assumes forecast </span><span class="si">{advnum}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;FORECAST&#39;</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hurricane advisory check failed: Must be local&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;FORECAST&#39;</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hurricane advisory check hard failed: Error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<span class="c1">#TODO change name periods to urls</span>

<span class="c1">##</span>
<span class="c1">## ADCIRC source subclass</span>
<span class="c1">##</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="s1">&#39;water_level&#39;</span><span class="p">,</span>
                <span class="n">datum</span><span class="o">=</span><span class="s1">&#39;MSL&#39;</span><span class="p">,</span> <span class="n">sitename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">castType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                <span class="n">fort63_style</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;zeta&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate the ADCIRC product layer. </span>
<span class="sd">        Parameters:</span>
<span class="sd">            station_id_list: &lt;list(str/tuple)&gt; input stations /station &amp; node</span>
<span class="sd">            periods: &lt;list(str)&gt; list of input URLs that span the desired time range</span>
<span class="sd">            product: &lt;str&gt; (default &#39;water_level&#39;) input generic product name</span>
<span class="sd">            datum: Not used here</span>
<span class="sd">            sitename: &lt;str&gt; (opt) used for amending metadata only</span>
<span class="sd">            gridname: &lt;str&gt; (opt) used for metadata only</span>
<span class="sd">            castType: &lt;str&gt; (opt) used for amending metadata only</span>
<span class="sd">            resample_mins: &lt;int&gt; resample time. Set to 0 for full resolution</span>
<span class="sd">            fort63_style: &lt;bool&gt; If true input station_ids as list of tuples (stationid/nodeid)</span>
<span class="sd">            variable_name: &lt;str&gt; (default=&#39;zeta&#39;) If using a SWAN type file then you must change the variable name here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">[</span><span class="n">product</span><span class="p">]</span>
        <span class="c1">#self._interval=interval </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datum</span><span class="o">=</span><span class="n">datum</span>
        <span class="n">periods</span><span class="o">=</span><span class="n">periods</span>
        <span class="k">if</span> <span class="n">castType</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;ADCIRC: castType not set. Will result in poor metadata NAME value&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_castType</span><span class="o">=</span><span class="n">castType</span> 
        <span class="k">if</span> <span class="n">gridname</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;ADCIRC: gridname not specified. Will result in poor metadata NAME value&#39;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_gridname</span><span class="o">=</span><span class="n">gridname</span>
        <span class="k">if</span> <span class="n">sitename</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;ADCIRC: sitename not specified. Will result in poor metadata NAME value&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sitename</span><span class="o">=</span><span class="n">sitename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="o">=</span><span class="n">variable_name</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;FS: Variable name is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fort63_style</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fetch station ids using fort.63 style&#39;</span><span class="p">)</span>
            <span class="n">available_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_adcirc_nodes_from_fort63_input_file</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fetch station ids using fort.61 style&#39;</span><span class="p">)</span>
            <span class="n">available_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_adcirc_nodes_from_fort61_input_file</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">available_stations</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;No valid fort file was found: Abort&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_stations_tuple</span><span class="o">=</span><span class="n">available_stations</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;List of ADCIRC generated stations </span><span class="si">{self.available_stations_tuple}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_empty_url_pointers</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">available_stations_tuple</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="n">resample_mins</span><span class="p">)</span> <span class="c1"># Pass in the full dict</span>

    <span class="k">def</span> <span class="nf">_fetch_adcirc_nodes_from_fort63_input_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_df</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        The Node index is decremented by one to better share subsequent code</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station_csv &lt;str&gt;. A list of station ids/Nodes in DataFrame format</span>
<span class="sd">            periods &lt;list&gt;. The list of url-63 values. </span>

<span class="sd">        Returns: list of tuples (stationid,nodeid). Superfluous stationids are ignored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Attempt to find ADCIRC fort_63 stations/Nodes&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fetch stations fort63 style: </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="p">)</span>
            <span class="n">station_df</span><span class="p">[</span><span class="s1">&#39;NodeMinusOne&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">station_df</span><span class="p">[</span><span class="s2">&quot;Node&quot;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># decrease nodeid by one to mimic the fort.61 indexing in subsequent code</span>
            <span class="n">station_ids</span> <span class="o">=</span> <span class="n">station_df</span><span class="p">[</span><span class="s2">&quot;stationid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="n">station_df</span><span class="p">[</span><span class="s2">&quot;NodeMinusOne&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">station_ids</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">idx</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;fort_63_style. Input file problematic </span><span class="si">{station_df}</span><span class="s1"> </span><span class="si">{e}</span><span class="s1">: Abort&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fetch_adcirc_nodes_from_fort61_input_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stations</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">():</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        periods contains all the possible urls. We do this because TDS may or may not actually</span>
<span class="sd">        have one or more of the requested urls. So we keep checking urls for stations until no more</span>
<span class="sd">        urls exist. If none, then die.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A list of (eg NOAA/Contrails) station ids</span>
<span class="sd">            periods &lt;list&gt;. The list of url-61 values. </span>

<span class="sd">        Returns: list of tuples (stationid,nodeid). Superfluous stationids are ignored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Attempt to find ADCIRC stations&#39;</span><span class="p">)</span>
        <span class="n">full_idx</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">url61</span> <span class="ow">in</span> <span class="n">periods</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fetch stations: </span><span class="si">{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url61</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">url61</span><span class="p">)</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">sn</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s1">&#39;station_name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">snn</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sn</span><span class="p">)):</span> <span class="c1"># This gets the stationids IN THE FILE not necc what we requested.</span>
                    <span class="n">ts</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
                    <span class="c1">#print(ts)</span>
                    <span class="n">snn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># Strips off actual name leaving only the leading id</span>
                <span class="c1"># Get intersection of input station ids and available ids</span>
                <span class="n">snn_pruned</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stations</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">snn</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># Build a list of tuples (stationid,nodeid)</span>
                <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span> <span class="c1"># Loop over stations to maintain order</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span> <span class="c1"># Supposed to pull out the first word</span>
                    <span class="c1"># Cnvert to a try clause</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snn_pruned</span><span class="p">:</span>
                        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is in list.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">snn</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not in fort.61.nc station_name list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                        <span class="c1">##sys.exit(1)</span>
                <span class="n">full_idx</span><span class="o">+=</span><span class="n">idx</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not open/read a specific fort.61 URL. Try next iteration </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url61</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Could not find ANY fort.61 urls from which to get stations lists </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Bottomed out in _fetch_adcirc_nodes_from_fort61_input_file&#39;</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
        <span class="c1"># Remove any duplicate tuples eg if len(periods) &gt; 1</span>
        <span class="n">full_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">full_idx</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">full_idx</span>

<div class="viewcode-block" id="adcirc_fetch_data.fetch_single_product"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.adcirc_fetch_data.fetch_single_product">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_tuple</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        variables.key() are now checked to try and determine if the dataset has been transposed (and rechunked) or not.</span>
<span class="sd">        If so, then fetching of the timeseries will be much, much faster but also requires chaning the code here a little</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station_tuple (&lt;str&gt;,&lt;int&gt;). A tuple that maps stationid to the current ADCIRC-grid nodeid</span>
<span class="sd">            periods &lt;list&gt;. A url-61 values. </span>

<span class="sd">       Returns: dataframe of time (timestamps) vs values for the requested stationid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First up. Get the list of available station ids</span>

        <span class="n">station</span><span class="o">=</span><span class="n">station_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node</span><span class="o">=</span><span class="n">station_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">datalist</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">typeCast_status</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span> <span class="c1"># Check each period to see if this was a nowcast or forecast type fetch. If mixed then abort</span>
        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">periods</span><span class="p">:</span> <span class="c1"># If a period is SHORT no data may be found esp for Contrails time ranges</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">nc4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;URL not found should never happen here. Should have been prefiltered: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">data_transposed</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span>
            <span class="k">if</span> <span class="n">data_transposed</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Expecting netCDF data in transposed form&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{self._variable_name}</span><span class="s1"> not found in netCDF for </span><span class="si">{url}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># okay to have a missing one  do not exit </span>
                <span class="c1"># sys.exit(1)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_var</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">nc4</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">time_var</span><span class="p">[:],</span> <span class="n">time_var</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">][:,</span><span class="n">node</span><span class="p">]</span> 
                    <span class="k">elif</span> <span class="n">nc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;node&#39;</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">nc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_name</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> 
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Unexpected leading variable name </span><span class="si">{ds.variables[v].dims}</span><span class="s1">: Abort&#39;</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Error: This is usually caused by accessing non-hsofs data but forgetting to specify the proper --grid </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="c1">#sys.exit()</span>
                <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)],</span> <span class="n">index</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">station</span><span class="p">]</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TIME&#39;</span>
                <span class="n">typeCast_status</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_ADCIRC_cast</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span> <span class="c1"># New pandas can only do this to strings now</span>
                <span class="n">datalist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">datalist</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;ADCIRC concat error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Check if ALL entries in typeCast_status are the same. If not fail hard.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">typeCast_status</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Some mix up with typeCast_status </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typeCast_status</span><span class="p">))</span>
            <span class="c1">#sys.exit(1)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_typeCast</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">typeCast_status</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;ADCIRC typeCast determined to be </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeCast</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df_data</span></div>
<span class="c1">##</span>
<span class="c1">## The nodelat/nodelon objects are masked arrays. For a single node (as used here)</span>
<span class="c1">## the ma.getdata() returns an ndarray of shape=() but with the a single value.</span>
<span class="c1">## Imposing a float() onto that value converts it to a real float</span>
<span class="c1">## Try to determine if this was a nowcast or a forecast type dataset</span>

<div class="viewcode-block" id="adcirc_fetch_data.fetch_single_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.adcirc_fetch_data.fetch_single_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        variables.key() are now checked to try and determine if the dataset has been transposed (and rechunked) or not.</span>
<span class="sd">        If so, then fetching of the timeseries will be much, much faster but also requires chaning the code here a little</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A valid station id</span>

<span class="sd">        Returns:</span>
<span class="sd">            dataframe of time (timestamps) vs values for the requested nodes </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">station</span><span class="o">=</span><span class="n">station_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node</span><span class="o">=</span><span class="n">station_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">periods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_periods</span>

        <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">periods</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">nc4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="c1"># we need to test access to the netCDF variables, due to infrequent issues with</span>
            <span class="c1"># netCDF files written with v1.8 of HDF5.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nodelon</span><span class="o">=</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
                <span class="n">nodelat</span><span class="o">=</span><span class="n">nc</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
                <span class="k">break</span><span class="p">;</span> 
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Meta not found. Trying another URL was</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                <span class="c1">#sys.exit()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">nodelat</span><span class="p">))</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">nodelon</span><span class="p">))</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span> 
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span> 
            <span class="c1"># meta[&#39;NAME&#39;]= nc.agrid # Long form of grid name description # Or possible use nc.version</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_gridname</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">_typeCast</span><span class="o">.</span><span class="n">upper</span><span class="p">()])</span> <span class="c1"># These values come from the calling routine and should be usually nowcast, forecast</span>
            <span class="c1">#meta[&#39;VERSION&#39;] = nc.version</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;UNITS&#39;</span><span class="p">]</span> <span class="o">=</span><span class="s1">&#39;m&#39;</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;TZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TIMEZONE</span> <span class="c1"># Can look in nc.comments</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;OWNER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">source</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;STATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;COUNTY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> 
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;SITE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sitename</span>
            <span class="n">df_meta</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
            <span class="n">df_meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">station</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Failed updating te ADCIRC station metadata for station </span><span class="si">{station}</span><span class="s1">, </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>

<span class="c1">#####################################################################################</span>
<span class="c1">##</span>
<span class="c1">## NOAA/NOS source subclass</span>
<span class="c1">##</span>

<div class="viewcode-block" id="noaanos_fetch_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.noaanos_fetch_data">[docs]</a><span class="k">class</span> <span class="nc">noaanos_fetch_data</span><span class="p">(</span><span class="n">fetch_station_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        station_id_list: list of NOAA station_ids &lt;str&gt;</span>
<span class="sd">        a tuple of (time_start, time_end) &lt;str&gt;,&lt;str&gt; format %Y-%m-%d %H:%M:%S</span>
<span class="sd">        a valid PRODUCT id &lt;str&gt;: hourly_height, water_level,predictions (tidal predictions)</span>
<span class="sd">        interval &lt;str&gt; set to &#39;h&#39; return hourly data, else 6min data</span>

<span class="sd">        Note: hourly_height data only appear for station after some time period (not sure how long that is). </span>

<span class="sd">        NOTE: Default to using imperial units. Because the metadata that gets returned only reports</span>
<span class="sd">        the units for how the data were stored not fetched. So it wouid be easy for the calling program to get confused.</span>
<span class="sd">        Let the caller choose to update units and modify the df_meta structure prior to DB uploads</span>

<span class="sd">        Two dicts are used to manage jobs. The first (products) maps generic product names used by high level codes</span>
<span class="sd">        to the specific product names in NOAA/NOS, The second (noaa_data_column_names) is used here internally to properly select </span>
<span class="sd">        the column name of the data</span>

<span class="sd">        UNITS listed as: https://api.tidesandcurrents.noaa.gov/api/prod/#units. Note this implies a hybrid MKS/CGS system and not MKS.</span>

<span class="sd">        Currently tested input products:</span>
<span class="sd">        water_level (default)</span>
<span class="sd">        predictions (Tidal predictions) </span>
<span class="sd">        air_pressure</span>
<span class="sd">        hourly_height</span>
<span class="sd">        wind_speed</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dict( persistant tag: source specific tag )</span>
    <span class="c1"># products defines current products (as keys) and uses the value as a column header in the returned data set</span>

    <span class="c1"># NOTE: This dict maps the generic input data type (key) to the actual product name used by noaa-coops</span>
    <span class="n">products</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;water_level&#39;</span><span class="p">:</span><span class="s1">&#39;water_level&#39;</span><span class="p">,</span>  <span class="c1"># 6 min</span>
               <span class="s1">&#39;predictions&#39;</span><span class="p">:</span> <span class="s1">&#39;predictions&#39;</span><span class="p">,</span> <span class="c1"># 6 min</span>
               <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span> <span class="s1">&#39;air_pressure&#39;</span><span class="p">,</span>
               <span class="s1">&#39;hourly_height&#39;</span><span class="p">:</span><span class="s1">&#39;hourly_height&#39;</span><span class="p">,</span> <span class="c1"># hourly</span>
               <span class="s1">&#39;wind_speed&#39;</span><span class="p">:</span><span class="s1">&#39;wind&#39;</span><span class="p">}</span>

    <span class="c1"># NOTE: This dict maps the input data type (key) to the COLUMN NAME that gets returned by noaa-coops</span>
    <span class="c1"># this value is not always the product name</span>
    <span class="n">noaa_data_column_names</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;water_level&#39;</span><span class="p">:</span><span class="s1">&#39;water_level&#39;</span><span class="p">,</span>  <span class="c1"># 6 min</span>
               <span class="s1">&#39;predictions&#39;</span><span class="p">:</span> <span class="s1">&#39;predicted_wl&#39;</span><span class="p">,</span> <span class="c1"># 6 min</span>
               <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span> <span class="s1">&#39;air_press&#39;</span><span class="p">,</span>
               <span class="s1">&#39;hourly_height&#39;</span><span class="p">:</span><span class="s1">&#39;water_level&#39;</span><span class="p">,</span> <span class="c1"># hourly</span>
               <span class="s1">&#39;wind&#39;</span><span class="p">:</span><span class="s1">&#39;spd&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="s1">&#39;water_level&#39;</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span> 
                <span class="n">datum</span><span class="o">=</span><span class="s1">&#39;MSL&#39;</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke the NOAA subclass</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station_id_list: &lt;list&gt; List of desired station ids</span>
<span class="sd">            periods: list of time-tuples indicating the desired time range(s)</span>
<span class="sd">            product: &lt;str&gt; (Default=&#39;water_level&#39;)  The generic product name</span>
<span class="sd">            interval: &lt;str&gt; NOAA coops specific param. None or &#39;h&#39;</span>
<span class="sd">            datum: &lt;str&gt; (Default=&#39;MSL&#39;)</span>
<span class="sd">            resample_mins: &lt;int&gt; time sampling. Specify 0 to get maximum resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span><span class="o">=</span><span class="n">map_product_to_harvester_units</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">[</span><span class="n">product</span><span class="p">]</span> <span class="c1"># self.products[product] # product</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NOAA Fetching product </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NOAA/NOS No such product key. Input </span><span class="si">{product}</span><span class="s1">, Available {self.products.keys()}: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span><span class="o">=</span><span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span> <span class="c1"># Redundant cleanup TODO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_datum</span><span class="o">=</span><span class="n">datum</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="n">resample_mins</span><span class="p">)</span>

<div class="viewcode-block" id="noaanos_fetch_data.check_duplicate_time_entries"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.noaanos_fetch_data.check_duplicate_time_entries">[docs]</a>    <span class="k">def</span> <span class="nf">check_duplicate_time_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">stationdata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sometimes station data comes back with multiple entries for a single time.</span>
<span class="sd">        Here we search for such dups and keep the FIRST one (Same as for ADDA)</span>
<span class="sd">        Choosing first was based on a single station and looking at the noaa coops website</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station: &lt;str&gt; an individual stationID to check</span>
<span class="sd">            stationData: &lt;dataframe&gt;. Current list of all station product levels (from detailedIDlist) </span>
<span class="sd">        Returns:</span>
<span class="sd">            New dataframe containing no duplicate values</span>
<span class="sd">            multivalue. bool: True if duplicates were found </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">multivalue</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">stationdata</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Duplicated Obs data found for station {str(station)} will keep first value(s) only&#39;</span><span class="p">)</span>
            <span class="n">stationdata</span> <span class="o">=</span> <span class="n">stationdata</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">stationdata</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)]</span>
            <span class="n">multivalue</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">stationdata</span><span class="p">,</span> <span class="n">multivalue</span></div>

<span class="c1"># The weirdness with tstart/tend. Prior work by us indicated noaa coops requires time formats of (%Y%m%d %H:%M&#39;)</span>
<span class="c1"># Even though their website says otherwise (as of Oct 2021)</span>

<div class="viewcode-block" id="noaanos_fetch_data.fetch_single_product"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.noaanos_fetch_data.fetch_single_product">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NOAA NOS site_id, process all the tuples from the input periods list</span>
<span class="sd">        and aggregate them into a dataframe with index pd.timestamps and a single column</span>
<span class="sd">        containing the desired product values. Rename the column to station id</span>
<span class="sd">        </span>
<span class="sd">        NOAA COOPS does not have the same time range constraints as Contrails. So this tuple list</span>
<span class="sd">        can, in fact, simply be the start and end time.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A valid station id</span>
<span class="sd">            time_range &lt;tuple&gt;. Start and end times (&lt;str&gt;,&lt;str&gt;) denoting time ranges</span>

<span class="sd">        Returns:</span>
<span class="sd">            dataframe of time (timestamps) vs values for the requested station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="o">=</span><span class="n">time_range</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;NOAA/NOS:Iterate: start time is </span><span class="si">{}</span><span class="s1">, end time is </span><span class="si">{}</span><span class="s1">, station is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">station</span><span class="p">))</span>
        <span class="n">timein</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">tstart</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">)</span>
        <span class="n">timeout</span> <span class="o">=</span>  <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">tend</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stationdata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">coops</span><span class="o">.</span><span class="n">Station</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">begin_date</span><span class="o">=</span><span class="n">timein</span><span class="p">,</span>
                                            <span class="n">end_date</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span>
                                            <span class="n">product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">,</span>
                                            <span class="n">datum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_datum</span><span class="p">,</span>
                                            <span class="n">units</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">,</span>
                                            <span class="n">interval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_interval</span><span class="p">,</span> <span class="c1"># If none defaults to 6min</span>
                                            <span class="n">time_zone</span><span class="o">=</span><span class="n">GLOBAL_TIMEZONE</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">noaa_data_column_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">]]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
            <span class="n">df_data</span><span class="p">,</span> <span class="n">multivalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_duplicate_time_entries</span><span class="p">(</span><span class="n">station</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1"># Put checks in here in case we want to exclude stations with determined multiple values</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;date_time&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">station</span><span class="p">]</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TIME&#39;</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df_data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ConnectionError</span> <span class="k">as</span> <span class="n">ec</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hard fail: Could not connect to COOPS for products </span><span class="si">{station}</span><span class="s1">: </span><span class="si">{ec}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">HTTPError</span> <span class="k">as</span> <span class="n">eh</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hard fail: HTTP error to COOPS for products: </span><span class="si">{eh}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Timeout</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Hard fail: Timeout&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NOAA/NOS data error: station </span><span class="si">{station}</span><span class="s1">: </span><span class="si">{e}</span><span class="s1"> was </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_data</span><span class="o">=</span><span class="n">df_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NOAA/NOS concat warning: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">df_data</span></div>

<span class="c1"># TODO The NOAA metadata scheme is Horrible for what we need. This example is very tentative </span>
<div class="viewcode-block" id="noaanos_fetch_data.fetch_single_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.noaanos_fetch_data.fetch_single_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NOAA site_id fetch the associated metadata.</span>
<span class="sd">        The choice of data is highly subjective at this time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">             A valid station id &lt;str&gt;</span>
<span class="sd">        Returns:</span>
<span class="sd">             dataframe of preselected metadata for a single station in the (keys,values) orientation</span>

<span class="sd">             This orientation facilitates aggregation upstream. Upstream will transpose this eventually</span>
<span class="sd">             to our preferred orientation with stations as index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">coops</span><span class="o">.</span><span class="n">Station</span><span class="p">(</span><span class="n">station</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;lng&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;lng&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;UNITS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span> <span class="c1"># UNITS # Manual override bcs -&gt; location.sensors[&#39;units&#39;] # This can DIFFER from the actual data. For data you can specify a transform to metric.</span>
            <span class="c1">#meta[&#39;ELEVATION&#39;] = location[&#39;elevation&#39;]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;TZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TIMEZONE</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;OWNER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NOAA/NOS&#39;</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;STATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">location</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;COUNTY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># None</span>
            <span class="c1">#</span>
            <span class="n">df_meta</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
            <span class="n">df_meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">station</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NOAA/NOS meta error station </span><span class="si">{station}</span><span class="s1">: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1">#sys.exit(1)</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>

<span class="c1">#####################################################################################</span>
<span class="c1">##</span>
<span class="c1">## CONTRAILS source subclass</span>
<span class="c1">## Fetching the Station data from Contrails managed by OneRain</span>
<span class="c1">##</span>

<span class="c1">## Must MANUALLY convert to metric here</span>

<div class="viewcode-block" id="contrails_fetch_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data">[docs]</a><span class="k">class</span> <span class="nc">contrails_fetch_data</span><span class="p">(</span><span class="n">fetch_station_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        station_id_list: list of station_ids &lt;str&gt;</span>
<span class="sd">        a tuple of (time_start, time_end) &lt;str&gt;,&lt;str&gt; format %Y-%m-%d %H:%M:%S</span>
<span class="sd">        a valid OWNER for Contrails &lt;str&gt;: One of NCDOT,Lake Lure,Asheville,Carolina Beach,</span>
<span class="sd">            Town of Cary,NCEM Synthetic,Wake County,</span>
<span class="sd">            USFWS,Morrisville,NCEM,USGS,NOAA,Currituck County,Duke Energy</span>
<span class="sd">        config: a dict containing values for domain &lt;str&gt;, method &lt;str&gt;, systemkey &lt;str&gt;</span>
<span class="sd">        a valid PRODUCT id &lt;str&gt;: See CLASSDICT definitions for specifics</span>

<span class="sd">        NOTE: Defaults to using imperial units. Manually correct them </span>

<span class="sd">        Two dicts are used to manage jobs. The first (products) maps generic product names used by high level codes</span>
<span class="sd">        to the specific product names in NOAA/NOS, The second (CLASSDICT) is used here internally map names to</span>
<span class="sd">        the data index used by Contrails</span>

<span class="sd">        Moreover, river guages and coastal guages get treated differently</span>

<span class="sd">        Currently tested input products:</span>
<span class="sd">        river_water_level </span>
<span class="sd">        coastal_water_level</span>
<span class="sd">        air_pressure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dict( persistant tag: source speciific tag )</span>

<span class="c1"># See Tom&#39;s email Regarding coastal versus river class values</span>
    <span class="n">products</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;river_water_level&#39;</span><span class="p">:</span><span class="s1">&#39;Stage&#39;</span><span class="p">,</span> 
               <span class="s1">&#39;coastal_water_level&#39;</span><span class="p">:</span><span class="s1">&#39;Water Elevation&#39;</span><span class="p">,</span>
               <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span><span class="s1">&#39;Barometric Pressure&#39;</span> 
             <span class="p">}</span>

    <span class="n">CLASSDICT</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Rain Increment&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s1">&#39;Rain Accumulation&#39;</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span>
        <span class="s1">&#39;Stage&#39;</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span>            <span class="c1"># River gauges</span>
        <span class="s1">&#39;Water Elevation&#39;</span><span class="p">:</span><span class="mi">94</span><span class="p">,</span>  <span class="c1"># Coastal gauges  - not documented in contrails doc as of early 2022</span>
        <span class="s1">&#39;Flow Volume&#39;</span><span class="p">:</span><span class="mi">25</span><span class="p">,</span>
        <span class="s1">&#39;Air Temperature&#39;</span><span class="p">:</span><span class="mi">30</span><span class="p">,</span>
        <span class="s1">&#39;Fuel Temperature&#39;</span><span class="p">:</span><span class="mi">38</span><span class="p">,</span>
        <span class="s1">&#39;Wind Velocity&#39;</span><span class="p">:</span><span class="mi">40</span><span class="p">,</span>
        <span class="s1">&#39;Wind Velocity, maximum&#39;</span><span class="p">:</span><span class="mi">41</span><span class="p">,</span>
        <span class="s1">&#39;Wind Direction&#39;</span><span class="p">:</span><span class="mi">44</span><span class="p">,</span>
        <span class="s1">&#39;ALERT Wind&#39;</span><span class="p">:</span><span class="mi">47</span><span class="p">,</span>
        <span class="s1">&#39;Relative Humidity&#39;</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span>
        <span class="s1">&#39;Soil Moisture&#39;</span><span class="p">:</span><span class="mi">51</span><span class="p">,</span>
        <span class="s1">&#39;Fuel Moisture&#39;</span><span class="p">:</span><span class="mi">52</span><span class="p">,</span>
        <span class="s1">&#39;Barometric Pressure&#39;</span><span class="p">:</span><span class="mi">53</span><span class="p">,</span>
        <span class="s1">&#39;Net Solar Radiation&#39;</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span>
        <span class="s1">&#39;Evapotranspiration Rate&#39;</span><span class="p">:</span><span class="mi">84</span><span class="p">,</span>
        <span class="s1">&#39;Binary Status&#39;</span><span class="p">:</span><span class="mi">197</span><span class="p">,</span>
        <span class="s1">&#39;Repeater Status&#39;</span><span class="p">:</span><span class="mi">198</span><span class="p">,</span>
        <span class="s1">&#39;Battery&#39;</span><span class="p">:</span><span class="mi">199</span><span class="p">,</span>
        <span class="s1">&#39;Average Voltage&#39;</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span>
        <span class="s1">&#39;Repeater Pass List&#39;</span><span class="p">:</span><span class="mi">240</span><span class="p">,</span>
        <span class="s1">&#39;Msg Count&#39;</span><span class="p">:</span><span class="mi">246</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># Here call a pipeline to do the fetch and then super the main class</span>
    <span class="c1"># We expect the calling metyhod to have resolved the different MAP terms for a given source</span>
    <span class="c1"># Currently only tested with the NCEM owner</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="s1">&#39;river_water_level&#39;</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="s1">&#39;NCEM&#39;</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invoke the Contrails subclass</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station_id_list: &lt;list&gt; List of desired station ids</span>
<span class="sd">            periods: list of time-tuples indicating the desired time range(s)</span>
<span class="sd">            product: &lt;str&gt; (Default=&#39;river_water_level&#39;)  The generic product name</span>
<span class="sd">            interval: &lt;str&gt; NOAA coops specific param. None or &#39;h&#39;</span>
<span class="sd">            owner: &lt;str&gt; (Default &#39;NCEM&#39;) a valid owner</span>
<span class="sd">            resample_mins: &lt;int&gt; time sampling. Specify 0 to get maximum resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="o">=</span><span class="n">owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span><span class="o">=</span><span class="n">map_product_to_harvester_units</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">[</span><span class="n">product</span><span class="p">]</span> <span class="c1"># product</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Contrails No such product key. Input </span><span class="si">{}</span><span class="s1">, Available </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">)</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;CONTRAILS Fetching product </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;systemkey&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="o">=</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;domain&#39;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="n">resample_mins</span><span class="p">)</span>

    <span class="c1"># Customized splitting of the timerange into a list of day-centric tuples.</span>

<div class="viewcode-block" id="contrails_fetch_data.return_list_of_daily_timeranges"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data.return_list_of_daily_timeranges">[docs]</a>    <span class="k">def</span> <span class="nf">return_list_of_daily_timeranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_tuple</span><span class="p">)</span><span class="o">-&gt;</span> <span class="nb">list</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take an arbitrary start and endtime (inclusive) in the format of %Y-%m-%d %H:%M:%S. Break up into a list of tuples which </span>
<span class="sd">        are at most a day in length AND break along day boundaries. [ {day1,day1),(day2,day2)..]</span>
<span class="sd">        The first tuple and the last tuple can be partial days. All intervening tuples will be full days.</span>
<span class="sd">    </span>
<span class="sd">        Assume an HOURLY stepping even though non-zero minute offsets may be in effect.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            A tuple consisting of:</span>
<span class="sd">            start_time: &lt;str&gt; Time of format %Y-%m-%d %H:%M:%S</span>
<span class="sd">            end_time: &lt;str&gt; Time of format %Y-%m-%d %H:%M:%S</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            periods: List of daily tuple ranges</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
        <span class="n">periods</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">dformat</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Parameters: start time </span><span class="si">{start_time}</span><span class="s1">, end_time </span><span class="si">{end_time}</span><span class="s1">&#39;</span><span class="p">)</span>
    
        <span class="n">time_start</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">dformat</span><span class="p">)</span>
        <span class="n">time_end</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">dformat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_start</span> <span class="o">&gt;</span> <span class="n">time_end</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Swapping input times&#39;</span><span class="p">)</span>
            <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">time_end</span><span class="p">,</span> <span class="n">time_start</span>
    
        <span class="n">today</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">today</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">time_end</span> <span class="o">&gt;</span> <span class="n">today</span><span class="p">:</span>
              <span class="n">time_end</span> <span class="o">=</span> <span class="n">today</span>
              <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Contrails: Truncating list: new end time is {dt.datetime.strftime(today, dformat)}&#39;</span><span class="p">)</span>
    
        <span class="c1">#What hours/min/secs are we starting on - compute proper interval shifting</span>
        <span class="n">init_hour</span> <span class="o">=</span> <span class="mi">24</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">time_start</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">init_min</span> <span class="o">=</span> <span class="mi">60</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">time_start</span><span class="o">.</span><span class="n">minute</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">init_sec</span> <span class="o">=</span> <span class="mi">60</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">time_start</span><span class="o">.</span><span class="n">second</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    
        <span class="n">oneSecond</span><span class="o">=</span><span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># An update interval shift</span>
    
        <span class="n">subrange_start</span> <span class="o">=</span> <span class="n">time_start</span>
        <span class="k">while</span> <span class="n">subrange_start</span> <span class="o">&lt;</span> <span class="n">time_end</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">hours</span><span class="o">=</span><span class="n">init_hour</span><span class="p">,</span> <span class="n">minutes</span><span class="o">=</span><span class="n">init_min</span><span class="p">,</span> <span class="n">seconds</span><span class="o">=</span><span class="n">init_sec</span><span class="p">)</span>
            <span class="n">subrange_end</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">subrange_start</span><span class="o">+</span><span class="n">interval</span><span class="p">,</span><span class="n">time_end</span><span class="p">)</span> <span class="c1"># Need a variable interval to prevent a day-span  </span>
            <span class="n">periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">subrange_start</span><span class="p">,</span><span class="n">dformat</span><span class="p">),</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">subrange_end</span><span class="p">,</span><span class="n">dformat</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">subrange_start</span><span class="o">=</span><span class="n">subrange_end</span><span class="o">+</span><span class="n">oneSecond</span> <span class="c1"># onehourint</span>
            <span class="n">init_hour</span><span class="p">,</span> <span class="n">init_min</span><span class="p">,</span> <span class="n">init_sec</span> <span class="o">=</span> <span class="mi">23</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">59</span>
        <span class="k">return</span> <span class="n">periods</span></div>

<div class="viewcode-block" id="contrails_fetch_data.build_url_for_contrails_station"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data.build_url_for_contrails_station">[docs]</a>    <span class="k">def</span> <span class="nf">build_url_for_contrails_station</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">systemkey</span><span class="p">,</span> <span class="n">indict</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a simple query for a single gauge and the product level values</span>
<span class="sd">        Parameters:</span>
<span class="sd">            domain: &lt;str&gt; contrails domain</span>
<span class="sd">            systemkey: &lt;str&gt; contrails authorization key</span>
<span class="sd">            indict: &lt;dict&gt; of parameters for the the final url</span>
<span class="sd">        Returns:</span>
<span class="sd">            full_url: &lt;str&gt; A fully formatted Contrails URL</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">url</span><span class="o">=</span><span class="n">domain</span>
        <span class="n">url_values</span><span class="o">=</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">(</span><span class="n">indict</span><span class="p">)</span>
        <span class="n">full_url</span> <span class="o">=</span> <span class="n">url</span> <span class="o">+</span><span class="s1">&#39;?&#39;</span> <span class="o">+</span><span class="n">url_values</span>
        <span class="k">return</span> <span class="n">full_url</span></div>

<div class="viewcode-block" id="contrails_fetch_data.convert_to_metric"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data.convert_to_metric">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contrails returns moost (all?) data in imperial units</span>
<span class="sd">        Here we convert valid productsa to metric</span>
<span class="sd">        The product selection is based on the native Contrails product names</span>
<span class="sd">        which is carried by self.product</span>

<span class="sd">        arbitrary_min = 600. Contrails can return pressures in mb OR inHg with little warning.</span>
<span class="sd">            depending on the station. We can&#39;t check here so try to deduce which units the data are in</span>
<span class="sd">      </span>
<span class="sd">        Dataframe is updated inplace</span>

<span class="sd">        Parameters</span>
<span class="sd">            df: &lt;dataframe&gt; Data of tmes x product for a specific station</span>
<span class="sd">        Returns:</span>
<span class="sd">            df: &lt;dataframe&gt; Data of times x product in metric units</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="n">arbitrary_min</span> <span class="o">=</span> <span class="mi">600</span> 
        <span class="n">product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_product</span>
        <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">product</span> <span class="o">==</span> <span class="s1">&#39;Stage&#39;</span> <span class="ow">or</span> <span class="n">product</span> <span class="o">==</span> <span class="s1">&#39;Water Elevation&#39;</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Contrails. Converting to meters&#39;</span><span class="p">)</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span> <span class="o">*</span> <span class="mf">0.3048</span> <span class="c1"># feet to meters</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="k">if</span> <span class="n">product</span> <span class="o">==</span> <span class="s1">&#39;Barometric Pressure&#39;</span><span class="p">:</span>
            <span class="n">test_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test_val</span> <span class="o">&lt;</span> <span class="n">arbitrary_min</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Contrails. Converting inHg to millibars (atm)&#39;</span><span class="p">)</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="mf">29.52998</span> 
            <span class="k">return</span> <span class="n">df</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;convert_to_metric: Dropped out the bottom. Unexpected product of </span><span class="si">{}</span><span class="s1">: Abort&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">product</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<span class="c1">## Now implement the required two methods</span>

<div class="viewcode-block" id="contrails_fetch_data.fetch_single_product"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data.fetch_single_product">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single Contrails site_id, process all tuples from the input periods list</span>
<span class="sd">        and aggregate them into a dataframe with index pd.timestamps and a single column</span>
<span class="sd">        containing the desired CLASSDICT[...] values. Rename the column to station id</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A valid station id</span>
<span class="sd">            time_range &lt;tuple&gt;. Start and end times (&lt;str&gt;,&lt;str&gt;) denoting time ranges</span>

<span class="sd">        Returns:</span>
<span class="sd">            dataframe of time (timestamps) vs values for the requested station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">METHOD</span> <span class="o">=</span> <span class="s1">&#39;GetSensorData&#39;</span>
        <span class="n">datalist</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_list_of_daily_timeranges</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tstart</span><span class="p">,</span><span class="n">tend</span> <span class="ow">in</span> <span class="n">periods</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Iterate: start time is </span><span class="si">{}</span><span class="s1">, end time is </span><span class="si">{}</span><span class="s1">, station is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">station</span><span class="p">))</span>
            <span class="n">indict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">METHOD</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLASSDICT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">],</span>
                 <span class="s1">&#39;system_key&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span> <span class="p">,</span><span class="s1">&#39;site_id&#39;</span><span class="p">:</span> <span class="n">station</span><span class="p">,</span>
                 <span class="s1">&#39;tz&#39;</span><span class="p">:</span> <span class="n">GLOBAL_TIMEZONE</span><span class="p">,</span>
                 <span class="s1">&#39;data_start&#39;</span><span class="p">:</span> <span class="n">tstart</span><span class="p">,</span><span class="s1">&#39;data_end&#39;</span><span class="p">:</span> <span class="n">tend</span> <span class="p">}</span>
            <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_url_for_contrails_station</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span><span class="p">,</span><span class="n">indict</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
                <span class="n">dict_data</span> <span class="o">=</span> <span class="n">xmltodict</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">dict_data</span><span class="p">[</span><span class="s1">&#39;onerain&#39;</span><span class="p">][</span><span class="s1">&#39;response&#39;</span><span class="p">][</span><span class="s1">&#39;general&#39;</span><span class="p">]</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">])</span> <span class="c1"># must be &lt;= 5000 entries returned</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[[</span><span class="s1">&#39;data_time&#39;</span><span class="p">,</span><span class="s1">&#39;data_value&#39;</span><span class="p">]]</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Contrails. Converting to meters&#39;</span><span class="p">)</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span><span class="n">station</span><span class="p">]</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;TIME&#39;</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">dx</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="n">datalist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Contrails response data error: Perhaps empty data contribution: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Manually convert all values to meters</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">datalist</span><span class="p">)</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Contrails. Converting to meters&#39;</span><span class="p">)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_metric</span><span class="p">(</span><span class="n">df_data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Contrails failed concat: error: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">df_data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">df_data</span></div>

<span class="c1"># According to oneRain the current best way to access the meta data is using or_site_id</span>
<span class="c1"># Also river and coastal metadata return different kind of objects</span>

<div class="viewcode-block" id="contrails_fetch_data.fetch_single_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.contrails_fetch_data.fetch_single_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>      
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single Contrails site_id fetch the associated metadata.</span>
<span class="sd">        Need to perform multiple queries to get the desired set of data. This is optional</span>
<span class="sd">        The caller will check the DB to see if this a new station requiring metadata</span>

<span class="sd">        Parameters:</span>
<span class="sd">             A valid station id &lt;str&gt;</span>
<span class="sd">        Returns:</span>
<span class="sd">             dataframe of preselected metadata for a single station in the (keys,values) orientation</span>

<span class="sd">             This orientation facilitates aggregation upstream. Upstream will transpose this eventually</span>
<span class="sd">             to our preferred orientation with stations as index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> 
        <span class="c1"># 1</span>
        <span class="n">METHOD</span> <span class="o">=</span> <span class="s1">&#39;GetSensorMetaData&#39;</span>
        <span class="n">indict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">METHOD</span><span class="p">,</span><span class="s1">&#39;tz&#39;</span><span class="p">:</span><span class="n">GLOBAL_TIMEZONE</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLASSDICT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">],</span>
             <span class="s1">&#39;system_key&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span> <span class="p">,</span><span class="s1">&#39;site_id&#39;</span><span class="p">:</span> <span class="n">station</span> <span class="p">}</span>
        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_url_for_contrails_station</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span><span class="p">,</span><span class="n">indict</span><span class="p">)</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">dict_data</span> <span class="o">=</span> <span class="n">xmltodict</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">dict_data</span><span class="p">[</span><span class="s1">&#39;onerain&#39;</span><span class="p">][</span><span class="s1">&#39;response&#39;</span><span class="p">][</span><span class="s1">&#39;general&#39;</span><span class="p">][</span><span class="s1">&#39;row&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;sensor_class&#39;</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">CLASSDICT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">]:</span>
                    <span class="n">list_sensor_id</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;or_sensor_id&#39;</span><span class="p">]</span> <span class="c1"># Yes a list of ordered dicts.</span>
                    <span class="n">or_site_id</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;or_site_id&#39;</span><span class="p">]</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">or_site_id</span><span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;or_site_id&#39;</span><span class="p">]</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Current or_site_id is </span><span class="si">{or_site_id}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># 2</span>
        <span class="n">METHOD</span> <span class="o">=</span> <span class="s1">&#39;GetSiteMetaData&#39;</span>
        <span class="c1">#indict = {&#39;method&#39;: METHOD,&#39;tz&#39;:GLOBAL_TIMEZONE, &#39;class&#39;: self.CLASSDICT[self._product],</span>
        <span class="c1">#     &#39;system_key&#39;: self._systemkey ,&#39;site_id&#39;: station }</span>
        <span class="n">indict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">METHOD</span><span class="p">,</span><span class="s1">&#39;tz&#39;</span><span class="p">:</span><span class="n">GLOBAL_TIMEZONE</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">CLASSDICT</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">],</span>
             <span class="s1">&#39;system_key&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span> <span class="p">,</span><span class="s1">&#39;or_site_id&#39;</span><span class="p">:</span> <span class="n">or_site_id</span> <span class="p">}</span>
        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_url_for_contrails_station</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_domain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_systemkey</span><span class="p">,</span><span class="n">indict</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
            <span class="n">dict_data</span> <span class="o">=</span> <span class="n">xmltodict</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">dict_data</span><span class="p">[</span><span class="s1">&#39;onerain&#39;</span><span class="p">][</span><span class="s1">&#39;response&#39;</span><span class="p">][</span><span class="s1">&#39;general&#39;</span><span class="p">][</span><span class="s1">&#39;row&#39;</span><span class="p">]</span>
            <span class="c1"># Gets here but then fails hard and returns for GTNN7</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;latitude_dec&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;latitude_dec&#39;</span><span class="p">]</span> <span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;longitude_dec&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;longitude_dec&#39;</span><span class="p">]</span> <span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span> <span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;UNITS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span> <span class="c1"># UNITS # Manual override bcs -&gt; data[&#39;units&#39;].replace(&#39;.&#39;,&#39;&#39;) # I have seen . in some labels</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;TZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TIMEZONE</span> <span class="c1"># data[&#39;utc_offset&#39;]</span>
            <span class="c1">###meta[&#39;ELEVATION&#39;] = data[&#39;elevation&#39;]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;OWNER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="c1"># data2 always returns the value=DEPRECATED data2[&#39;owner&#39;]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;STATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># None # data2[&#39;state&#39;]  # DO these work ?</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;COUNTY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1">#</span>
            <span class="n">df_meta</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
            <span class="n">df_meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">station</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Contrails response meta error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>

<span class="c1">#####################################################################################</span>
<span class="c1">##</span>
<span class="c1">## NOAA/NDBC source Realtime subclass</span>
<span class="c1">##</span>

<div class="viewcode-block" id="ndbc_fetch_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_data">[docs]</a><span class="k">class</span> <span class="nc">ndbc_fetch_data</span><span class="p">(</span><span class="n">fetch_station_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invoke the NDBC subclass</span>

<span class="sd">        This class develops the realtime data</span>
<span class="sd">        Realtime data goes back now()-45days. </span>

<span class="sd">    Parameters:</span>
<span class="sd">        station_id_list: list of NDBC buoy ids &lt;str&gt;</span>
<span class="sd">        a tuple of (time_start, time_end) &lt;str&gt;,&lt;str&gt; format %Y-%m-%d %H:%M:%S</span>
<span class="sd">        a valid PRODUCT id &lt;str&gt;: wave_height,pressure, wind_speed</span>

<span class="sd">        One dict is used to manage jobs. The products dict maps generic product names used by high level codes</span>
<span class="sd">        (keys) to the specific product names in NDBC </span>

<span class="sd">        UNITS: Based on an examinination of the data and comparison to plots on the NDBC website, it appears that</span>
<span class="sd">        at least for the tested stations:</span>
<span class="sd">            wave_height: meters</span>
<span class="sd">            pressure: mbars </span>
<span class="sd">            wind_speed: m/s</span>
<span class="sd"> </span>
<span class="sd">        Currently tested input products:</span>
<span class="sd">            wave_heigh</span>
<span class="sd">            pressure</span>
<span class="sd">            wind_speed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dict( persistant tag: source specific tag )</span>
    <span class="c1"># products defines current products (as keys) and uses the value as a column header in the returned data set</span>

    <span class="c1"># NOTE: This dict maps the generic input data type (key) to the actual product name used by noaa-coops</span>

    <span class="n">products</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;wave_height&#39;</span><span class="p">:</span><span class="s1">&#39;WVHT&#39;</span><span class="p">,</span> <span class="c1"># m</span>
               <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span><span class="s1">&#39;PRES&#39;</span><span class="p">,</span> <span class="c1"># hPa=mb</span>
               <span class="s1">&#39;wind_speed&#39;</span><span class="p">:</span><span class="s1">&#39;WSPD&#39;</span><span class="p">}</span> <span class="c1"># mps</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="s1">&#39;wave_height&#39;</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span>
                <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NDBC: National Data Buoy Center</span>
<span class="sd">        Read buoy product data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            station_id_list: List of triplets [(id,name,state)...]</span>
<span class="sd">            periods: A tuple of time range (timein,timeend).format %Y-%m-%d %H:%M:%S</span>
<span class="sd">            product: &lt;str&gt; (Default=&#39;wave_height&#39;)  The generic product name</span>
<span class="sd">            resample_mins: &lt;int&gt; time sampling. Specify 0 to get maximum resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span><span class="o">=</span><span class="n">map_product_to_harvester_units</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">[</span><span class="n">product</span><span class="p">]</span> <span class="c1"># self.products[product] # product</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC Fetching product </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC No such product key. Input </span><span class="si">{product}</span><span class="s1">, Available {self.products.keys()}&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span> <span class="c1"># Redundant cleanup TODO</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">!=</span><span class="s1">&#39;metric&#39;</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC: units must be metric: </span><span class="si">{units}</span><span class="s1">: Abort&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="n">resample_mins</span><span class="p">)</span>

<span class="c1">#TODO metric con versions</span>
<div class="viewcode-block" id="ndbc_fetch_data.fetch_single_product"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_data.fetch_single_product">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NDBC site_id, process the tuple from the input period.</span>
<span class="sd">        Aggregate them into a dataframe with index pd.timestamps and a single column</span>
<span class="sd">        containing the desired product values. Rename the column to station id</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A valid NDBC buoy id</span>
<span class="sd">            time_range &lt;tuple&gt;. Start and end times (&lt;str&gt;,&lt;str&gt;) denoting time ranges</span>

<span class="sd">        Returns:</span>
<span class="sd">            dataframe of time (timestamps) vs values for the requested station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="o">=</span><span class="n">time_range</span>

        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;NDBC: Iterate: start time is </span><span class="si">{}</span><span class="s1">, end time is </span><span class="si">{}</span><span class="s1">, buoy is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">NDBC</span><span class="o">.</span><span class="n">realtime_observations</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">realtime</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">df</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">txt</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TIME&#39;</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># From lowest to highest</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">df_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">df_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ConnectionError</span> <span class="k">as</span> <span class="n">ec</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hard fail: Could not connect to NDBC for products </span><span class="si">{bouy[0]}</span><span class="s1">: </span><span class="si">{ec}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">HTTPError</span> <span class="k">as</span> <span class="n">eh</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hard fail: HTTP error to NDBC for products: </span><span class="si">{eh}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Timeout</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Hard fail NDBC: Timeout&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC data error: </span><span class="si">{e}</span><span class="s1"> was </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_data</span><span class="o">=</span><span class="n">df_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC concat error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">df_data</span></div>

<div class="viewcode-block" id="ndbc_fetch_data.fetch_single_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_data.fetch_single_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NDBC site_id fetch the associated metadata.</span>
<span class="sd">        The choice of metadata is highly subjective at this time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">             A valid buoy id &lt;str&gt;</span>
<span class="sd">        Returns:</span>
<span class="sd">             dataframe of preselected metadata for a single station in the (keys,values) orientation</span>

<span class="sd">             This orientation facilitates aggregation upstream. Upstream will transpose this eventually</span>
<span class="sd">             to our preferred orientation with stations as index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">df_latest</span> <span class="o">=</span> <span class="n">NDBC</span><span class="o">.</span><span class="n">latest_observations</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;station&#39;</span><span class="p">)</span>
        <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">df_latest</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">]][[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span><span class="s1">&#39;longitude&#39;</span><span class="p">]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">buoy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;UNITS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span> 
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;TZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TIMEZONE</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;OWNER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NONE&#39;</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;STATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">buoy</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;COUNTY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># None</span>
        <span class="n">df_meta</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">df_meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>

<span class="c1">##</span>
<span class="c1">## NOAA/NDBC source historical subclass</span>
<span class="c1">##</span>

<div class="viewcode-block" id="ndbc_fetch_historic_data"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_historic_data">[docs]</a><span class="k">class</span> <span class="nc">ndbc_fetch_historic_data</span><span class="p">(</span><span class="n">fetch_station_data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invoke the NDBC historical subclass</span>
<span class="sd">        This class develops the historical data</span>
<span class="sd">        Historical data will not return data from the current year.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        station_id_list: list of NDBC buoy ids &lt;str&gt;</span>
<span class="sd">        a tuple of (time_start, time_end) &lt;str&gt;,&lt;str&gt; format %Y-%m-%d %H:%M:%S</span>
<span class="sd">        a valid PRODUCT id &lt;str&gt;: wave_height,pressure, wind_speed</span>

<span class="sd">        One dict is used to manage jobs. The products dict maps generic product names used by high level codes</span>
<span class="sd">        (keys) to the specific product names in NDBC </span>

<span class="sd">        UNITS: Based on an examinination of the data and comparison to plots on the NDBC website, it appears that</span>
<span class="sd">        at least for the tested stations:</span>
<span class="sd">            wave_height: meters</span>
<span class="sd">            pressure: mbars </span>
<span class="sd">            wind_speed: m/s</span>
<span class="sd"> </span>
<span class="sd">        Currently tested input products:</span>
<span class="sd">            wave_height</span>
<span class="sd">            pressure</span>
<span class="sd">            wind_speed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># dict( persistant tag: source specific tag )</span>
    <span class="c1"># products defines current products (as keys) and uses the value as a column header in the returned data set</span>

    <span class="c1"># NOTE: This dict maps the generic input data type (key) to the actual product name used by noaa-coops</span>

    <span class="n">products</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;wave_height&#39;</span><span class="p">:</span><span class="s1">&#39;WVHT&#39;</span><span class="p">,</span> <span class="c1"># m</span>
               <span class="s1">&#39;air_pressure&#39;</span><span class="p">:</span><span class="s1">&#39;PRES&#39;</span><span class="p">,</span> <span class="c1"># hPa=mb</span>
               <span class="s1">&#39;wind_speed&#39;</span><span class="p">:</span><span class="s1">&#39;WSPD&#39;</span><span class="p">}</span> <span class="c1"># mps</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">product</span><span class="o">=</span><span class="s1">&#39;wave_height&#39;</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span><span class="p">,</span>
                <span class="n">resample_mins</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NDBC: National Data Buoy Center</span>
<span class="sd">        Read Historical buoy product data.</span>

<span class="sd">        Parameters</span>
<span class="sd">            station_id_list: :List of triplets [(id,name,state)...]</span>
<span class="sd">            periods: A tuple of time range (timein,timeend).format %Y-%m-%d %H:%M:%S</span>
<span class="sd">            product: &lt;str&gt; (Default=&#39;wave_height&#39;)  The generic product name</span>
<span class="sd">            resample_mins: &lt;int&gt; time sampling. Specify 0 to get maximum resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span><span class="o">=</span><span class="n">map_product_to_harvester_units</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">[</span><span class="n">product</span><span class="p">]</span> <span class="c1"># self.products[product] # product</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC Fetching Historicalproduct </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC No such historical product key. Input </span><span class="si">{product}</span><span class="s1">, Available {self.products.keys()}&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">=</span><span class="s1">&#39;metric&#39;</span> <span class="c1"># Redundant cleanup TODO</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">!=</span><span class="s1">&#39;metric&#39;</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;NDBC: units must be metric: </span><span class="si">{}</span><span class="s1">: Abort&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">units</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">station_id_list</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">resample_mins</span><span class="o">=</span><span class="n">resample_mins</span><span class="p">)</span>

<div class="viewcode-block" id="ndbc_fetch_historic_data.get_year_list_from_timerange"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_historic_data.get_year_list_from_timerange">[docs]</a>    <span class="k">def</span> <span class="nf">get_year_list_from_timerange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The input time_range tuple is queried to determine what year we are interested in.</span>
<span class="sd">        No checks are made to ensure the CURRENT year is excluded. If it is included,</span>
<span class="sd">        then the subsequent historical data call will fail</span>

<span class="sd">        Parameters:</span>
<span class="sd">            input time tuple: (&lt;str&gt;,&lt;str&gt;) formats are &#39;%Y-%m-%d %H:%M:%S&#39;</span>
<span class="sd">        Returns:</span>
<span class="sd">            year_list: list sorted range of years</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dformat</span> <span class="o">=</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span>
        <span class="n">yin</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dformat</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
        <span class="n">yout</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dformat</span><span class="p">)</span><span class="o">.</span><span class="n">year</span>
        <span class="k">if</span> <span class="n">yin</span> <span class="o">&gt;</span> <span class="n">yout</span><span class="p">:</span>
            <span class="n">yin</span><span class="p">,</span><span class="n">yout</span> <span class="o">=</span> <span class="n">yout</span><span class="p">,</span><span class="n">yim</span>
        <span class="n">year_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">yin</span><span class="p">,</span><span class="n">yout</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">year_list</span></div>

<span class="c1">## Implement the required two methods</span>

<div class="viewcode-block" id="ndbc_fetch_historic_data.fetch_single_product"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_historic_data.fetch_single_product">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">time_range</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NDBC site_id, process the tuple from the input period.</span>
<span class="sd">        Aggregate them into a dataframe with index pd.timestamps and a single column</span>
<span class="sd">        containing the desired product values. Rename the column to station id</span>
<span class="sd">   </span>
<span class="sd">        As of this writing, it is unclear if the time_range argument to buoypy </span>
<span class="sd">        works. So I build this year_list approach to be sure</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            station &lt;str&gt;. A valid NDBC buoy id</span>
<span class="sd">            time_range &lt;tuple&gt;. Start and end times (&lt;str&gt;,&lt;str&gt;) denoting time ranges</span>

<span class="sd">        Returns:</span>
<span class="sd">            dataframe of time (timestamps) vs values for the requested station</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="o">=</span><span class="n">time_range</span>

        <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;NDBC_HISTORIC: Iterate: start time is </span><span class="si">{}</span><span class="s1">, end time is </span><span class="si">{}</span><span class="s1">, buoy is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span><span class="n">tend</span><span class="p">,</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">data_list</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="n">year_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_year_list_from_timerange</span><span class="p">(</span><span class="n">time_range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">year_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC_HISTORICAL: Found year </span><span class="si">{year}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">H</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">historic_data</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">year</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">get_stand_meteo</span><span class="p">()</span> 
                <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;TIME&#39;</span>
                <span class="n">df_data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_product</span><span class="p">]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
                <span class="n">df_data</span><span class="o">.</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">df_data</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># From lowest to highest</span>
                <span class="n">df_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="mf">99.0</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ConnectionError</span> <span class="k">as</span> <span class="n">ec</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hard fail: Could not connect to NDBC for products </span><span class="si">{buoy[0]}</span><span class="s1">: </span><span class="si">{ec}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">HTTPError</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Hard fail: HTTP error to NDBC for products&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Timeout</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Hard fail NDBC: Timeout&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC data error: </span><span class="si">{e}</span><span class="s1"> was </span><span class="si">{self._product}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_data</span><span class="o">=</span><span class="n">df_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC_HISTORIC float assignment error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">df_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">df_data</span> <span class="o">=</span> <span class="n">df_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">df_data</span></div>

<div class="viewcode-block" id="ndbc_fetch_historic_data.fetch_single_metadata"><a class="viewcode-back" href="../../harvester.html#harvester.fetch_station_data.ndbc_fetch_historic_data.fetch_single_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_single_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a single NDBC site_id fetch the associated metadata.</span>
<span class="sd">        The choice of data is highly subjective at this time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">             A valid buoy id &lt;str&gt;</span>
<span class="sd">        Returns:</span>
<span class="sd">             dataframe of preselected metadata for a single station in the (keys,values) orientation</span>

<span class="sd">             This orientation facilitates aggregation upstream. Upstream will transpose this eventually</span>
<span class="sd">             to our preferred orientation with stations as index</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="n">meta</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
            <span class="n">df_latest</span> <span class="o">=</span> <span class="n">NDBC</span><span class="o">.</span><span class="n">latest_observations</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;station&#39;</span><span class="p">)</span>
            <span class="n">df_latest</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;dump.csv&#39;</span><span class="p">)</span>
            <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">df_latest</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">]][[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span><span class="s1">&#39;longitude&#39;</span><span class="p">]]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LAT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;LON&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;NAME&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">buoy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;UNITS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_unit</span> 
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;TZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">GLOBAL_TIMEZONE</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;OWNER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;NONE&#39;</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;STATE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">buoy</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;COUNTY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># None</span>
            <span class="n">df_meta</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
            <span class="n">df_meta</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">buoy</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
             <span class="k">pass</span>
             <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Station </span><span class="si">{buoy[0]}</span><span class="s1"> had no metadata: skip it&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">utilities</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;NDBC Historical meta error: </span><span class="si">{e}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_meta</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">AST</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../harvester.html">harvester package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../processing.html">processing package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utilities.html">utilities package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, AST: AdcircSupportTools: RENCI EDS.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>